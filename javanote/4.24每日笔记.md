## static 静态域与静态方法
修饰静态成员和类成员
- 静态成员：从类第一次加载时就会产生，直到不再存在任何对象使用才会被释放
- 类成员：可用 类名.类成员 进行调用

- 静态方法
  - 被static修饰的方法不需要创建对象就可以直接对方法进行调用；
  - 不能对对象实施操作的方法，
  - 在静态方法中不能够使用this
  - 静态方法中不能够直接访问非静态成员，只能够直接调用静态成员

- 静态常量
  - `static final 变量名` 
  - 的
- final实例域 
- 静态变量

## 构造方法


## 代码块
- 普通代码块
  - 在方法中定义的为普通代码块，顺序执行先出现先执行；
- 类代码块
  - 又称为构造代码块，在类中定义，创建对象时调用，编译时会被加入到构造方法中，优先于构造方法执行；
```
class Main{
    {
    }
}
```
- 静态代码块
  - 类加载时调用，优先于构造代码块执行，并且无论产生多少实例，只执行一次
```
class Main{
    static{
    }
}
``` 
- 代码块执行顺序：无论是类属性变量的初始化还是代码块的执行，首先是静态代码块执行，并且按照从上往下的先后顺序执行；然后是
类代码块顺序执行

## 练习
1. 以下代码的输出结果是
> 应当为C. 15 28 22 28  
> 因为num1是一个成员变量，会根据不同的对象赋值有所改变，而num2是一个类成员，在类第一次加载时就会产生，而后面用类中对象调用num2赋值都会改变这个值；所以最终为28。

2. 以下选项插入到代码片段中可以编译通过的是
> B 和 D都可以编译通过，
> 首先A中 exam1 被定义是一个常量，所以在第一个代码块中无法再进行改变；而C中 第二个代码块是一个静态代码块，不能够引用非静态变量
3. 以下代码的输出结果是
> 输出结果为 A. O C A, 首先在声明加载类的时候会调用静态成员 
4. 以下代码哪一行会编译错误
> C
> StaticDemo.method3(); // 3 这里使用类名直接进行调用
> void method3() {} 是一个实例方法，应当使用对象进行调用，而不是直接用方法名进行调用

