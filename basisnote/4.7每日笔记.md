- [数据结构与算法](#%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e4%b8%8e%e7%ae%97%e6%b3%95)
  - [顺序表](#%e9%a1%ba%e5%ba%8f%e8%a1%a8)
  - [链表](#%e9%93%be%e8%a1%a8)
  - [循环链表](#%e5%be%aa%e7%8e%af%e9%93%be%e8%a1%a8)
  - [作业](#%e4%bd%9c%e4%b8%9a)

# 数据结构与算法
数据结构是计算机存储、组织数据的方式，它是指相互之间存在一种或多种特定关系的数据元素的集合。
1. 数据结构分类
   - 逻辑结构：逻辑结构反映的是数据元素之间的关系，它们与数据元素在计算机中的存储位置无关，是数据结构在用户面前所呈现的形式。
      - 集合
      - 线性结构：顺序存储和链式存储
      - 树形结构：数据元素之间存在一对多的层次关系
      - 图形结构：数据元素存在多对多的关系，每个结点的前驱和后继结点都可以是任意个。
   - 存储结构
      - 顺序存储结构：把逻辑上相邻的结点存储在地址连续的存储单元里，数组元素之间的关系由存储单元是否相邻来体现。如数组
      - 链式存储结构：一些不连续的存储单元，这些存储单元的逻辑关系通过附加的指针字段来表示
      - 索引存储结构：在存储结点信息的同时，还建立附加的索引表。
      - 散列存储结构：又称为哈希存储，通过一定的函数关系（散列函数，也称为哈希函数）计算出一个值，将这个值作为元素的存储地址。
## 顺序表
顺序存储结构，是线性表的一种。
1. 实现
   - 首先要定义顺序表的指针变量
   - 顺序表申请的存储容量；
   - 顺序表的长度，也就是表中存储数据元素的个数；
2. 插入元素
   - 一般插入顺序首先找到插入目标的位置
   - 然后增加分配内存
   - 将插入位置后的元素依次向后移一位
   - 将插入元素值赋给空出的位置
   - 将表长度加1
3. 删除元素
   - 找到删除的位置；
   - 将删除位置后的元素依次向前移动；
   - 重新分配减少内存
   - 表的长度减1
4. 查找元素
   - 从顺序表的第一个元素依次查找
5. 修改元素
   - 查找要修改的元素，返回其下标
   - 然后将要修改的元素值赋给其下标元素

6. 优点：  
   1) 空间利用率高。（局部性原理，连续存放，命中率高） 
   2) 存取速度高效，通过下标来直接存储。
7. 缺点：
   1) 插入和删除比较慢，O(n)时间复杂度，
   2) 不可以增长长度，有空间限制,当需要存取的元素个数可能多于顺序表的元素个数时,会出现"溢出"问题.当元素个数远少于预先分配的空间时,空间浪费巨大。

## 链表
链式存储结构或单链表，存储逻辑关系为 "一对一" 的数据，链表不限制数据的物理存储状态，其物理存储位置是随机的。
1. 节点
   - 数据元素本身，其所在的区域称为数据域；
   - 指向直接后继元素的指针，所在的区域称为指针域；
2. 头节点
   - 头指针：永远指向链表第一个节点的位置的一个指针
   - 头结点：其实就是一个不存任何数据的空结点，通常作为链表的第一个结点。
   - 首元结点：由于头结点（也就是空结点）的缘故，链表中称第一个存有数据的结点为首元结点。
   - 其他结点：链表中其他的结点。
3. 创建
   - 声明一个头指针（如果有必要，可以声明一个头结点）
   - 创建多个存储数据的结点，在创建的过程中，随时与其前驱结点建立逻辑关系。
4. 插入
   - 将新结点的 next 指针指向插入位置后的结点；
   - 将插入位置前结点的 next 指针指向插入结点；
   - `add->next = p->next;` `p->next = add;`
5. 删除
   - 将要插入位置的前一个结点的 next 指针指向其位置的下一个结点；
   - 将删除的结点释放,并指向NULL
   - `p->next = del->next;` `free(del);` `del=NULL;`
6. 查找元素
   - 从表头依次遍历表中结点，用被查找元素与各结点数据域中存储的数据元素进行比对，直至比对成功或遍历至链表最末端的 NULL。
7. 修改元素
   - 通过遍历找到存储此元素的节点，对节点中的数据域做更改操作即可。
8. 优点
   1) 插入和删除速度快，保留原有的物理顺序，时间复杂度 O(1);
   2) 没有空间限制,存储元素的个数无上限,基本只与内存空间大小有关。
9. 缺点
   1) 占用额外的空间以存储指针
   2) 查找速度慢，因为查找时，需要循环链表访问，需要从开始节点一个一个节点去查找元素访问。时间复杂度 O(n) 。

## 循环链表
- 将链表的两头进行连接，即将尾部结点不再指向NULL，而是指向元首结点,当只有一个结点时指向自身。
```c
#include <stdio.h>
#include <stdlib.h>
typedef struct node{
    int number;
    struct node * next;
}Node;
Node* initNode(int n){
    Node *head=(Node *)malloc(sizeof(Node));
    head->number=1;
    head->next=NULL;
    Node * cyclic=head;
    for (int i=2; i<=n; i++) {
        Node * body=(Node*)malloc(sizeof(Node));
        body->number=i;
        body->next=NULL; 
        cyclic->next=body;
        cyclic=cyclic->next;
    }
    cyclic->next=head;
    return head;
}
```



## 作业
- 链表图解

![1](https://github.com/lioil9/note-book/blob/master/image/%E5%8D%95%E9%93%BE%E8%A1%A8%E5%9B%BE%E8%A7%A3.jpg)