## 内部类

内部类隐藏在外部类内，可以更好的实现信息的隐藏；

- 分类
	- 成员内部类
	- 静态内部类
	- 局部内部类
	- 匿名内部类

- 语法
```java
public class Outer {
    class Inner {       
    }
}
```
- 内部类可以使用`private`、`protected`、`static` 访问修饰符

### 成员内部类

- 内部类在外部使用时，无法直接实例化，需要先实例化一个外部类对象然后通过外部类对象才能实例化；  
- 有了一个内部类，则一定会存在一个外部类对象，所以可以直接在内部类中访问外部类的私有属性和方法（**当出现同名属性时在内部类中会优先访问内部类中的**），而外部类中可以实例化内部类来访问其私有数据；  
- 在内部类中直接用 `this` 指代的是内部类对象，而使用 `外部类名.this` 指代的是外部类对象  
- 非静态内部类中不能够包含静态属性，方法和代码块，因为其是依赖外部类对象的，而静态类是属于类的，并不依赖对象，所以会发生冲突；但是内部类中可以有常量。  

### 静态内部类

- 静态内部类在类class前加static修饰，将其与类关联起来，不依赖外部类对象可直接创建对象；（外部类的上一级程序单元是包，所以不能够使用static进行修饰）；
- 静态内部类不能够访问外部类的非静态属性和方法，静态内部类可以包含非静态的属性和方法，（与外部类的使用一致）；
- 静态内部类是外部类的静态成员，所以在外部类可以直接用 `内部类名.` 来对内部的静态属性和方法进行调用，而在其他类中访问则用 `外部类名.内部类名.` 进行调用；而调用非静态属性和方法，则可以通过新建外部类对象来进行调用；
- 在内部类中当内部类属性与外部类属性同名时，默认直接调用内部类中的成员。

### 局部内部类

- 一般可定义在方法中，作用范围也在方法内；  
- 和方法内部成员的使用规则一样，class前不能有`public private protected static` 修饰符；  
- 类中不能包含静态成员；  
- 类中可以包含`final abstract `修饰的成员；  
### 匿名内部类
- 可用来快速创建一个抽象类或者接口的实现类，相当于一个没有名字的实现类；  
- 创建匿名内部类会立刻创建该类的实例，但类的定义不能重复使用；  
- 匿名内部类中不能够包含抽象方法，因为其要立刻实例化不能被其他类重写；并且不能定义构造器，因为其没有类名无法构造，可以通过构造代码块进行对象的初始化；  
- 当匿名内部类创建时可以将其赋给其要实现的抽象类或接口的引用，但其引用只能够调用其重写的方法，不能够调用匿名内部类独有的方法，若要调用只能够在创建后 `.` 进行调用。  
#### 局部和匿名内部类中使用局部变量
- 匿名或局部内部类中如果使用了方法中的局部变量，需要保证该变量是final的；（java8之前，需要显示指定变量是final的，java8之后，编译器可以自动在变量前增加final，Effectively Final）  
- 如果在外部有对变量的重复赋值操作，说明这一定不是final类型的变量，编译器无法增加final修饰，会导致匿名内部类里面报错  
- 内部类的成员变量的成员变量就没有必须是`final`的限制，因为其生命周期跟随从堆内存中创建出来的对象，生命周期和匿名类一致，可以在匿名类中正常使用，并且匿名类中对变量值进行修改是对所有引用外部类对象的变量都生效的；  
> 注：局部变量在方法调用结束后内存释放，而局部内部类和匿名内部类中的方法可以在之后调用，此时局部变量被释放会产生问题，所以使用的是局部变量的副本，而为了标识使用局部变量的副本，所以用final来修饰表示。  

### 接口中的内部类
- 接口中的内部接口或者类都是 `public static` ，即只能是静态内部类；  
- 接口中的内部接口可以用来定义一组常量，使用内部接口将常量分组。