## 双向链表
- 理解双向链表的增删操作
1. 双向链表的构造
   - 双向链表与单链表不同的是其每个结点有两个指针
   - 所以在构造时需要定义三个部分， pre指针、next 指针和存储的数据值
```c
typedef struct node {
    struct node *pre;
    struct node *next;
    int elem;
} Node;
```
2. 插入结点操作
   1) 在头部插入(pos = 0)
        - 首先创建要插入的结点分配空间
        - 然后将要插入的结点next指针指向head结点 `add->next=head;`
        - 判断头结点是否为空，将头节点pre指针指向插入结点 `if (head != null) head->pre = add;`
        - 最后将头结点为新插入结点 `head = add;`

   2) 在尾部插入
        - 将尾部结点的next指针指向插入结点 `tail->next = add;` 然后将插入结点的pre指针指向尾部结点`add->prev = tail;` 
        - 最后将尾部结点赋给新插入结点 `tail = add;`

   3) 在中间插入
        - 首先定义头结点 `Node* pre = head;`
        - 然后利用for循环找到要插入的位置，并将其位置的的上一个结点next指针定义，然后存储要插入位置的结点，
`for (k = 0; k < i-1; k++)pre = pre->next; Node* aft = pre->next`
       - 最后将插入结点的next指针指向插入位置的结点，然后将插入位置的pre指针指向插入结点 `add->next = aft; aft->pre = add;`
       - 再将插入位置的上一结点的next指针指向插入位置的结点，将插入结点的pre指针指向它，`pre->next = add; add->pre = pre;`

3. 删除结点操作
    1) 头部结点删除
        - 判断链表是否为空，为空时返回链表
        - 将头结点的下一个结点赋值为头结点， `del = head` `head = head->next;`
        - 再将新的头结点pre指针指向NULL `if (head != null) head->pre = NULL;`
        - 再将删除结点释放 `free(del);`
    2) 尾部结点删除
        - 将尾部结点的上一个结点赋值，`del = tail;``tail = tail->pre;`
        - 将新定义的尾部结点指向NULL `tail->next = null;` `free(del);`
    3) 中间结点删除
        - 类似于插入结点，首先定义头结点，然后查找删除结点位置； `Node* pre = head;` `for (k = 0; k < i-1; k++)pre = pre.next;`
        - 将删除结点的上一个结点指向下一个结点，然后将下一个结点指向上一个结点。 `Node* del = pre->next, aft = del->next` `pre->next = aft; aft->pre = pre;`

## 循环链表
- 约瑟夫环问题
1. 用循环列表来解决
   - 

2. 用数组来解决


- 理解约瑟夫环使用循环链表来解决的思路
- 搜索并理解约瑟夫环使用数组来解决的思路

## 栈
- 使用栈的数据结构实现后缀表达式的计算
