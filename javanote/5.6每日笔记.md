## 多态（polymorphism）

允许不同类的对象对同一消息做出不同的反应

- 分类
	- 编译时多态：设计时多态方法重载
	- 运行时多态：程序运行时动态决定调用哪个方法
- 必要条件
	- 满足继承关系
	- 父类引用指向子类对象
- 语法

```java
父类 变量名 = new 子类();
// 如果子类重写了父类方法，则这里调用的是子类中定义的方法
变量名.父类方法(); 
```

> 注：当父类方法中是静态的方法时，子类同名方法也必须是静态的，且并不构成重写，调用子类的静态方法时会自动屏蔽父类的方法，静态方法不存在多态性

- 向上转型（隐式转型，自动转型）
	- 父类引用指向子类实例
	- 可以调用子类重写父类的方法以及父类派生的方法，无法调用子类独有方法
	- 父类中静态方法无法被重写，所以向上转型之后，只能调用父类原有的静态方法
- 向下转型（强制类型转换）
	- 子类引用指向父类对象，此处必须进行强制转换，可以调用子类特有的方法
	- 必须满足转型条件才能进行强制转换 `(数据类型) 变量`
	- instanceof 判断某个对象是否满足特定类实例特征，返回 true/false
		- 语法：`对象 instanceof 类`表示左边的对象是否是右边类的实例，或是其子类的实例
- 多态方法的调用
	- 如果是私有方法、静态方法或final方法这些方法不存在继承，因此可以直接判断调用哪个方法
	- 如果是其他的方法，根据变量中具体的对象类型到指定的类下面查找匹配的方法，如果当前没有定义这个方法，就到上一级父类中查找，找到之后进行方法调用。

## 抽象类

某个父类只是知道其子类应该包含怎样的方法，但是无法准确知道这些子类如何实现这些方法

- 抽象类不会被实例化，但是可以定义构造方法，
- 如果抽象类中定义了final成员，但没有在声明本身中初始化它们，必须有一个构造函数来初始化这些成员
- 子类构造方法可以调用抽象类的一个构造方法，如果抽象类中没有提供无参的构造方法，则子类构造方法中必须调用抽象类中的构造方法。
- 使用规则  
	1. abstract定义抽象类  
	2. 抽象类不能直接实例化，只能够被继承，可以通过向上转型来完成对象实例  
	3. abstract定义抽象方法不需要具体实现，子类中需要重写父类的抽象方法。  
> 包含抽象类方法的类一定是抽象类。

### 扩展：

#### 静态类



#### 嵌套类

